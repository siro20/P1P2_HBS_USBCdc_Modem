#pragma once
#include "message.hpp"

#define P1P2_DAIKIN_CMD_REQUEST 0x00
#define P1P2_DAIKIN_CMD_ANSWER  0x40

#define P1P2_DAIKIN_TYPE_SENSE_EXT_CTRL  0x30
#define P1P2_DAIKIN_TYPE_STATUS_EXT_CTRL 0x31
#define P1P2_DAIKIN_TYPE_PARAM_EXT_CTRL  0x32
#define P1P2_DAIKIN_TYPE_EXT_LAST        0x3f

#define  P1P2_DAIKIN_STATUS_USER_ACT 0x80

#define P1P2_DAIKIN_DEFAULT_EXT_CTRL_ADDR 0xF0

//
// Act as Daiking external controller
// Response to address 0xF0,0xF1,... on the P1P2 bus.
//
class StandaloneController
{
  public:
    StandaloneController();

    // Process received message.
    void Receive(const Message *in);

    // Periodic state machine function
    // Must be regulary called.
    void Check(void);

    // Returns true when TxAnswer should be transmitted.
    // Only true as long as TxAnswer() has not been called.
    // Only true till another packet is received, aka. Receive() is called.
    bool HasTxData(void);

    // The Msg to be transmitted.
    // Calling this functions resets HasTxData()
    void TxAnswer(Message *out);

    // A bus collision on Tx Msg happened.
    void BusCollision(void);

    // Returns true if packet is generated by this instance.
    bool IsTxAnswer(const Message *in);

    // Caches a message and transmits it on the next available slot
    bool CacheTxMessage(Message& in);

    // Check if received packet needs to be handled
    bool NeedToHandlePacket(const Message *in);

    // Received a valid paket that needs to be handled.
    // Generates a response message.
    void GenerateAnswer(const Message *in);

  private:
    enum CTRL_STATE {
      IDLE = 0,
      BUS_SCAN,
      OPERATING,
    };

    uint8_t GenCRC(const Message *in, size_t len);
    // Message to answer latest request
    Message Answer;
    // Cached responses for Packet 32h - 3fh
    Message Packet3xh[14];
    // The address to listen on
    size_t Address;
    // Has message to transmit
    bool Ready;
    // Statemachine
    enum CTRL_STATE State;
    // Counter used in the state machine
    absolute_time_t IdleCounterMs;
};
