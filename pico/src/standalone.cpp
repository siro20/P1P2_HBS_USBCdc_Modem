#include <stdio.h>
#include <pico/platform.h>
#include <pico/stdlib.h>

#include "standalone.hpp"

#define TIMEOUT_IDLE_MS 100
#define TIMEOUT_BUS_SCAN 2000
#define TIMEOUT_OPERATION 600000

// Response to specific packets on the bus to
// emulate an 'external controller'.

StandaloneController::StandaloneController() :
	Answer{}, Address(P1P2_DAIKIN_DEFAULT_EXT_CTRL_ADDR),
	Ready(false), State(IDLE),
	IdleCounterMs(make_timeout_time_ms(TIMEOUT_IDLE_MS)) {

	this->Answer.Data[0] = P1P2_DAIKIN_CMD_ANSWER;
	this->Answer.Data[1] = this->Address;
}

// Periodic state machine function
// Must be regulary called.
void StandaloneController::Check(void) {
	switch (this->State) {
	case IDLE:
		// Wait 100 msec to finish possible TxAnswer being sent
		if (time_reached(this->IdleCounterMs)) {
			this->State = BUS_SCAN;
			this->IdleCounterMs = make_timeout_time_ms(TIMEOUT_BUS_SCAN);
		}
	break;
	case BUS_SCAN:
		// Scan the bus for external controller activity
		if (time_reached(this->IdleCounterMs)) {
			this->State = OPERATING;
			this->IdleCounterMs = make_timeout_time_ms(TIMEOUT_OPERATION);
		}
	break;
	case OPERATING:
		// Every 10 minutes stop normal operation for scanning external controller
		if (time_reached(this->IdleCounterMs)) {
			this->State = IDLE;
			this->Ready = false;
			this->IdleCounterMs = make_timeout_time_ms(TIMEOUT_IDLE_MS);
		}
	break;
	}
}

// Receive a paket and decide if it's valid
// and needs to be handled.
void StandaloneController::Receive(const Message *in) {
	if (in->Length <= 3)
		return;

	switch (this->State) {
	case IDLE:
		return;
	case BUS_SCAN:
		if ((in->Data[0] == P1P2_DAIKIN_CMD_ANSWER) &&
		    (in->Data[1] == this->Address) &&
		    (in->Data[2] == P1P2_DAIKIN_TYPE_SENSE_EXT_CTRL) &&
		    (this->GenCRC(in, in->Length - 1) == in->Data[in->Length - 1])) {
			// Found a conflicting external controller!
			// Switch to next address.
			this->Address++;
			if (this->Address > 0xF1)
				this->Address = P1P2_DAIKIN_DEFAULT_EXT_CTRL_ADDR;
			this->Answer.Data[1] = this->Address;
			this->Answer.Data[17] = this->GenCRC(&this->Answer, 17);
		}
		break;
	case OPERATING:
		if (this->NeedToHandlePacket(in) &&
		    this->GenCRC(in, in->Length - 1) == in->Data[in->Length - 1]) {
			this->GenerateAnswer(in);
		} else {
			this->Ready = false;
		}
		break;
	}
}

bool StandaloneController::NeedToHandlePacket(const Message *in) {
	if (in->Data[0] != P1P2_DAIKIN_CMD_REQUEST) {
		// External controller only answers requests.
		// Ignore answers.
		return false;
	}
	if (in->Data[1] != this->Address) {
		// Only accept packets for the external controller address.
		return false;
	}

	switch (in->Data[2]) {
	case P1P2_DAIKIN_TYPE_SENSE_EXT_CTRL:
		// Response here to enable communication using packets 00f031..00f03f
		return true;
	break;
	case P1P2_DAIKIN_TYPE_STATUS_EXT_CTRL:
		// Do pretend to be a LAN adapter (even though this may trigger "data not in sync" upon restart?)
		// If we don't set address, installer mode in main thermostat may become inaccessible
		return true;
	break;
	}
	return false;
}

// Received a valid paket that needs to be handled
// Generates a response message.
void StandaloneController::GenerateAnswer(const Message *in) {
	switch (in->Data[2]) {
	case P1P2_DAIKIN_TYPE_SENSE_EXT_CTRL:
		this->Answer.Data[2] = P1P2_DAIKIN_TYPE_SENSE_EXT_CTRL;
		for (int i = 3; i < 17; i++) {
			this->Answer.Data[i] = in->Data[i];
		}

		this->Answer.Length = 18;
	break;
	case P1P2_DAIKIN_TYPE_STATUS_EXT_CTRL:
		this->Answer.Data[2] = P1P2_DAIKIN_TYPE_STATUS_EXT_CTRL;
		for (int i = 3; i < 15; i++) {
			this->Answer.Data[i] = in->Data[i];
		}
		this->Answer.Data[7] = 0xB4; // LAN adapter ID in 0x31 payload byte 7
		this->Answer.Data[8] = 0x10; // LAN adapter ID in 0x31 payload byte 8
		this->Answer.Length = 16;
	break;
	default:
		this->Ready = false;
		return;
	}

	this->Answer.Data[this->Answer.Length - 1] =
			this->GenCRC(&this->Answer, this->Answer.Length - 1);
	this->Ready = true;
}

// Returns true when TxAnswer should be transmitted.
// Only true as long as TxAnswer() has not been called.
// Only true till another packet is received, aka. Receive() is called
bool StandaloneController::HasTxData(void) {
	return this->Ready;
}

// The Msg to be transmitted.
// Calling this functions resets HasTxData()
void StandaloneController::TxAnswer(Message *out) {
	out->Length = this->Answer.Length;
	for (int i = 0; i < out->Length; i++) {
		out->Data[i] = this->Answer.Data[i];
	}
	this->Ready = false;
}

void StandaloneController::BusCollision(void) {
	// On bus collision scan bus for conflicting external controllers
	this->State = IDLE;
	this->IdleCounterMs = make_timeout_time_ms(TIMEOUT_IDLE_MS);
	this->Ready = false;
}

// Returns true if packet is generated by this instance.
bool StandaloneController::IsTxAnswer(const Message *in) {
	if (in->Data[0] != P1P2_DAIKIN_CMD_ANSWER)
		return false;

	if (in->Data[1] == this->Address)
		return false;

	return (in->Data[2] == P1P2_DAIKIN_TYPE_SENSE_EXT_CTRL) ||
	       (in->Data[2] == P1P2_DAIKIN_TYPE_STATUS_EXT_CTRL);
}

// Calculates the CRC over Data[0]..Data[len - 1]
// Using uint32_t/size_t for faster assembly code.
uint8_t StandaloneController::GenCRC(const Message *in, size_t len) {
	uint32_t crc = 0;
	for (size_t j = 0; j < len; j++) {
		uint32_t c = in->Data[j];
		for (size_t i = 0; i < 8; i++) {
			if ((crc ^ c) & 0x01) {
				crc = (crc >> 1) ^ 0xd9;
			} else {
				crc = (crc >> 1);
			}
			c >>= 1;
		}
	}
	return crc & 0xff;
}

